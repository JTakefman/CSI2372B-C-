// CSI2372 example Code
// Lecture 05 and Lecture 06
// ==========================================================================
// (C)opyright:
//
//   Mohammad Alnabhan
//   SITE, University of Ottawa
//   800 King Edward Ave.
//   Ottawa, On., K1N 6N5
//   Canada. 
// 
// Creator: Malnabha (Mohammad Alnabhan)
// Email:   Malnabha@uottawa.ca
// ==========================================================================
/* Review:
Pass by Reference
passing objects by reference avoids unnecessary copying of large objects. By passing a reference, you directly modify the original object without calling the copy constructor, making the program more efficient.
*/
class Point2D {
public:
    double x, y;

    Point2D(double _x = 0.0, double _y = 0.0) : x(_x), y(_y) {}

    Point2D subtract(const Point2D& other) const {
        return Point2D(x - other.x, y - other.y);
    }
	
	//Note: const ensures that functions or objects are not modified. When a method is declared const, it means that it wonâ€™t alter any data members of the class.
};
// ==========================================================================
/* Class Relationships: Aggregation:
"has-a" relationship between classes. For example, a Rectangle has two Point2D objects representing its corners.
*/

class Rectangle {
private:
    Point2D bottomLeft, topRight;

public:
    Rectangle(const Point2D& bl, const Point2D& tr) : bottomLeft(bl), topRight(tr) {}

    double area() const {
        return (topRight.x - bottomLeft.x) * (topRight.y - bottomLeft.y);
    }
	
	// The Rectangle class aggregates two Point2D objects to define its geometry.
};
// ==========================================================================
/* Association Class Relationship:
    Association refers to a "uses-a" relationship between two classes. In this case, one class uses or interacts with another but does not own or contain it. Association allows one object to communicate with another.
*/
class Student {
public:
    void study() {
        std::cout << "Student is studying" << std::endl;
    }
};

class Teacher {
public:
    void instruct(Student& student) {
        student.study();  // Teacher interacts with Student through association
    }
	//  Teacher is associated with Student, but neither class contains an instance of the other.
};
	
// ==========================================================================
/* Copy Constructor: is called when a new object is created from an existing object.
If not explicitly defined, the compiler provides a default copy constructor, which performs a shallow copy.
For classes with dynamic memory, you may need to implement a deep copy.

- Shallow copy: The default copy constructor generated by the compiler copies pointers as-is, meaning both the original and the copied object will point to the same memory.
- Deep copy: The user-defined copy constructor allocates new memory and copies the content of the original object into the new object, preventing shared memory issues.
*/

class Point2D {
public:
    double* x;
    double* y;

    // Constructor
    Point2D(double _x, double _y) {
        x = new double(_x);   // // Allocate memory on the heap
        y = new double(_y);
    }

    // Deep copy constructor - to ensure that when an object is copied, new memory is allocated for its data members.
    Point2D(const Point2D& other) {
        x = new double(*other.x);
        y = new double(*other.y);
    }

    // Destructor
    ~Point2D() {
        delete x;
        delete y;
    }
};
// ==========================================================================
/* Virtual Destructors
When using inheritance, you need a virtual destructor in the base class to ensure the derived class destructor is called when deleting a derived class object through a base class pointer.*/
class Shape {
public:
    virtual ~Shape() {
        std::cout << "Shape destructor called" << std::endl;
    }
};

class Circle : public Shape {
public:
    ~Circle() {
        std::cout << "Circle destructor called" << std::endl;
    }
};

int main() {
    Shape* shape = new Circle();
    delete shape;  // Calls both Circle and Shape destructors
    return 0;
}
// ==========================================================================
/* Structs
A struct in C++ is similar to a class but with public members by default.
It is often used for simple aggregate types, where the members are grouped together but do not have behavior (functions).
*/
struct Point2D {
    double x, y;  // Public members by default
};

struct Rectangle {
    Point2D bottomLeft, topRight;  // Aggregation of two Point2D objects
};
// ==========================================================================

/* Inheritance and Generalization
Inheritance allows a class to inherit attributes and methods from another class, forming an "is-a" relationship.

Effect of Access Modifiers (Private, Protected, Public):
    Private: Members are only accessible within the class itself. Even derived classes cannot access private members directly.
    Protected: Members are accessible within the class and derived classes, but not from outside.
    Public: Members are accessible from anywhere.
	
*/
class Shape {
public:
    virtual double area() const = 0;  // Pure virtual function (abstract class)
    virtual ~Shape() {}  // Virtual destructor to ensure proper cleanup
};

class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    // Override the area method
    double area() const override {
        return 3.1415 * radius * radius;
    }
	// Check Slide 35 in Lecture05+06 document in Brightspace.
};
// ==========================================================================
/*
There are three types of inheritance in C++:
    Public Inheritance: The public and protected members of the base class remain public and protected in the derived class.
    Protected Inheritance: The public and protected members of the base class become protected in the derived class.
    Private Inheritance: The public and protected members of the base class become private in the derived class.
*/
class Base {
protected:
    int protectedVar;

public:
    Base() : protectedVar(100) {}
};

// Public inheritance
class DerivedPublic : public Base {
public:
    void display() {
        std::cout << "Protected var in public inheritance: " << protectedVar << std::endl;
    }
};

// Protected inheritance
class DerivedProtected : protected Base {
public:
    void display() {
        std::cout << "Protected var in protected inheritance: " << protectedVar << std::endl;
    }
};

// Private inheritance
class DerivedPrivate : private Base {
public:
    void display() {
        std::cout << "Protected var in private inheritance: " << protectedVar << std::endl;
    }
};

int main() {
    DerivedPublic pub;
    pub.display();  // Works because inheritance is public

    DerivedProtected prot;
    prot.display();  // Works, but you cannot access protectedVar directly from main()

    DerivedPrivate priv;
    priv.display();  // Works, but protectedVar is not accessible from main()
	
	// Trying to access `protectedVar` directly from main using objects would fail
    // pub.protectedVar;  // Error: 'protectedVar' is protected within this context
    // prot.protectedVar; // Error: 'protectedVar' is protected within this context
    // priv.protectedVar; // Error: 'protectedVar' is private within this context

    return 0;
}
// ==========================================================================
/* The final Keyword prevents further inheritance or method overriding. It can be applied to a class or a virtual function.
    Final Class: Prevents the class from being used as a base class.
    Final Method: Prevents a virtual method from being overridden in derived classes.
*/

class Base {
public:
    virtual void func() final {  // No derived class can override this method
        std::cout << "Base function" << std::endl;
    }
};

class Derived : public Base {
    // Attempting to override func() here will cause a compilation error
};

// Final class
class FinalClass final {
public:
    void display() {
        std::cout << "This class cannot be inherited." << std::endl;
    }
};

class AnotherClass : public FinalClass {}; // This would cause an error
